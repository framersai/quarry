/**
 * FABRIC Codex Viewer - Main orchestrator component
 * Coordinates sidebar, content, metadata panel, and state management
 * @module codex/CodexViewer
 */

'use client'

import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { useSearchParams, useRouter, usePathname } from 'next/navigation'
import { Info, FileText, X } from 'lucide-react'
import Image from 'next/image'
import type { GitHubFile, SidebarMode, FrameCodexViewerProps, StrandMetadata, TagsIndex, TagIndexEntry } from './types'
import type { MoveOperation } from './tree/types'
import { parseWikiMetadata, shouldIgnorePath, isMarkdownFile } from './utils'
import { API_ENDPOINTS, REPO_CONFIG } from './constants'
import { useGithubTree } from './hooks/useGithubTree'
import { useCodexHotkeys } from './hooks/useCodexHotkeys'
import { useBookmarks } from './hooks/useBookmarks'
import { usePreferences } from './hooks/usePreferences'
import { useSwipeGesture } from './hooks/useSwipeGesture'
import { useTextToSpeech } from './hooks/useTextToSpeech'
import { clearAllCodexData, getLastViewedLocation, saveLastViewedLocation } from '@/lib/localStorage'
import { saveStrandMetadata, type SaveResult } from '@/lib/content/saveStrandMetadata'
import { reindexStrandMetadata } from '@/lib/jobs/reindexStrand'
import { getCachedStrand, setCachedStrand } from '@/lib/codexCache'
import { getDailyFacts, type StudyStats } from '@/lib/codex/facts'
import { useFeatureFlags } from '@/lib/config/featureFlags'
import CodexSidebar from './CodexSidebar'
import CodexContent from './CodexContent'
import CodexMetadataPanel from './CodexMetadataPanel'
import CodexToolbar from './CodexToolbar'
// MobileToggle replaced with centered inline button
import MetadataToggleFAB from './ui/MetadataToggleFAB'
import MediaCaptureFAB from './ui/MediaCaptureFAB'
import SidebarCollapseToggle from './ui/SidebarCollapseToggle'
import BookmarksPanel from './ui/BookmarksPanel'
import CodexSettingsModal from './ui/CodexSettingsModal'
import TutorialTour from './ui/TutorialTour'
import HelpInfoPanel from './ui/HelpInfoPanel'
import MobileBottomNav from './ui/MobileBottomNav'
import QuarryBrand from './ui/QuarryBrand'
import dynamic from 'next/dynamic'

// Lazy load heavy components for better initial load performance
const KnowledgeGraphView = dynamic(() => import('./ui/KnowledgeGraphView'), { ssr: false })
const FabricGraphView = dynamic(() => import('./ui/FabricGraphView'), { ssr: false })
const TimelineView = dynamic(() => import('./ui/TimelineView'), { ssr: false })
const ContributeModal = dynamic(() => import('./ui/ContributeModal'), { ssr: false })
const ApiStatusBanner = dynamic(() => import('./ui/ApiStatusBanner'), { ssr: false })
const SettingsModal = dynamic(() => import('./ui/SettingsModal'), { ssr: false })
const StrandEditor = dynamic(() => import('./ui/StrandEditor'), { ssr: false })
const UnifiedAskInterface = dynamic(() => import('./ui/UnifiedAskInterface'), { ssr: false })
const FlashcardQuizPopover = dynamic(() => import('./ui/FlashcardQuizPopover'), { ssr: false })
const GlossaryPopover = dynamic(() => import('./ui/GlossaryPopover'), { ssr: false })
const StrandMindMap = dynamic(() => import('./ui/StrandMindMap'), { ssr: false })
const KeyboardShortcutsModal = dynamic(() => import('./ui/KeyboardShortcutsModal'), { ssr: false })
const MovePublishModal = dynamic(() => import('./ui/MovePublishModal'), { ssr: false })
import { PendingMovesBadge } from './ui/MovePublishModal'
import { TUTORIALS, type TutorialId } from './tutorials'
import { useSearchFilter } from './hooks/useSearchFilter'
import { useResponsiveLayout, Z_INDEX } from './hooks/useResponsiveLayout'
import { getSearchEngine } from '@/lib/search/engine'
import type { CodexSearchResult } from '@/lib/search/types'
import SearchResultsPanel from './ui/SearchResultsPanel'
import { useDateIndex } from './hooks/useDateIndex'
import { useTreeSelection } from './hooks/useTreeSelection'
import { useJobQueue, JOB_TYPE_LABELS } from './hooks/useJobQueue'
import { useToast } from './ui/Toast'
import { pluginEvents, setViewerHooks, clearViewerHooks, pluginUIRegistry } from '@/lib/plugins/QuarryPluginAPI'
import { quarryPluginManager } from '@/lib/plugins/QuarryPluginManager'

// Lazy load JobStatusPanel
const JobStatusPanel = dynamic(() => import('./ui/JobStatusPanel'), { ssr: false })

// Lazy load CodexWelcomeStats for home page
const CodexWelcomeStats = dynamic(() => import('./ui/CodexWelcomeStats'), { ssr: false })

type SummaryIndexEntry = {
  path?: string
  metadata?: {
    summary?: string
    tags?: string | string[]
    taxonomy?: {
      subjects?: string[]
      topics?: string[]
    }
    autoGenerated?: {
      lastIndexed?: string
    }
  }
}

/**
 * Main FABRIC Codex viewer component
 * 
 * @remarks
 * **Features:**
 * - Full-screen modal or embedded page mode
 * - Knowledge tree with hierarchical navigation
 * - Advanced search (name + full-text, case-sensitive)
 * - Markdown rendering with syntax highlighting
 * - Wiki-style internal links
 * - Metadata panel with backlinks
 * - Keyboard shortcuts (m, /, g h, s)
 * - Mobile-responsive (80vw sidebar, 56px FAB, 44px+ touch targets)
 * - Analog styling (paper texture, inner shadows)
 * - URL-based navigation with query params
 * 
 * **Architecture:**
 * - Modular: 8 components + 3 hooks + utilities
 * - Type-safe: Full TypeScript with TSDoc
 * - Accessible: ARIA labels, keyboard nav, focus management
 * - Performant: Debounced search, pagination, lazy loading
 * 
 * @example
 * ```tsx
 * // Modal mode
 * <FrameCodexViewer
 *   isOpen={modalOpen}
 *   onClose={() => setModalOpen(false)}
 *   mode="modal"
 * />
 * 
 * // Page mode
 * <FrameCodexViewer
 *   isOpen={true}
 *   mode="page"
 *   initialPath="weaves/tech"
 * />
 * ```
 */
export default function FrameCodexViewer({
  isOpen,
  onClose,
  mode = 'modal',
  initialPath = '',
  initialFile = null,
}: FrameCodexViewerProps) {
  const router = useRouter()
  const pathname = usePathname()
  const searchParams = useSearchParams()
  const {
    preferences,
    updateTheme,
    updateFontSize,
    updateTreeDensity,
    updateDefaultSidebarMode,
    updateSidebarOpenMobile,
    updateMetadataPanelSize,
    updateMultiple,
    reset: resetPreferences,
  } = usePreferences()

  // State
  const [currentPath, setCurrentPath] = useState('')
  const [files, setFiles] = useState<GitHubFile[]>([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [selectedFile, setSelectedFile] = useState<GitHubFile | null>(null)
  const [fileContent, setFileContent] = useState<string>('')
  const [fileMetadata, setFileMetadata] = useState<StrandMetadata>({})
  // Full index map stores complete metadata including autoGenerated fields
  // NOTE: Must be declared before metadataMap which depends on it
  const [fullIndexMap, setFullIndexMap] = useState<Map<string, { metadata?: StrandMetadata & { autoGenerated?: Record<string, unknown> } }>>(
    () => new Map()
  )
  // Build metadata map for advanced filtering from the full index
  const metadataMap = useMemo(() => {
    const map = new Map<string, StrandMetadata>()
    fullIndexMap.forEach((entry, path) => {
      if (entry.metadata) {
        map.set(path, entry.metadata as StrandMetadata)
      }
    })
    return map
  }, [fullIndexMap])

  // Build date index for calendar filtering
  const { dateIndex } = useDateIndex(metadataMap)

  const {
    options: searchOptions,
    setQuery: setSearchQueryInput,
    toggleSearchNames,
    toggleSearchContent,
    toggleCaseSensitive,
    setFilterScope,
    toggleHideEmptyFolders,
    setRootScope,
    filteredFiles,
    resetFilters: resetSearchFilters,
    // Advanced filters
    advancedFilters,
    setDateFilter,
    toggleTag,
    setSelectedTags,
    setTagMatchMode,
    toggleSubject,
    setSelectedSubjects,
    toggleTopic,
    setSelectedTopics,
    excludePath,
    includePath,
    resetAdvancedFilters,
    activeAdvancedFilterCount,
    hasAdvancedFilters,
  } = useSearchFilter(files, new Map(), metadataMap)
  const [sidebarMode, setSidebarMode] = useState<SidebarMode>('tree')
  const [sidebarOpen, setSidebarOpen] = useState(true)
  const [sidebarWidth, setSidebarWidth] = useState(320)
  const [sidebarFontSize, setSidebarFontSize] = useState(1) // 0=xs, 1=sm, 2=base, 3=lg
  const [metaOpen, setMetaOpen] = useState(true)
  // Right panel is now unified - CodexMetadataPanel handles its own tabs internally
  const [expandedTreePaths, setExpandedTreePaths] = useState<Set<string>>(new Set())
  const [bookmarksOpen, setBookmarksOpen] = useState(false)
  const [preferencesOpen, setPreferencesOpen] = useState(false)
  const [activeTutorial, setActiveTutorial] = useState<TutorialId | null>(null)
  const [helpOpen, setHelpOpen] = useState(false)
  const [graphOpen, setGraphOpen] = useState(false)
  const [fabricGraphOpen, setFabricGraphOpen] = useState(false)
  const [timelineOpen, setTimelineOpen] = useState(false)
  const [contributeOpen, setContributeOpen] = useState(false)
  const [settingsOpen, setSettingsOpen] = useState(false)
  const [editorOpen, setEditorOpen] = useState(false)
  const [editorDraft, setEditorDraft] = useState<{ content: string; metadata: StrandMetadata } | null>(null)
  const [qaOpen, setQAOpen] = useState(false)
  const [flashcardsOpen, setFlashcardsOpen] = useState(false)
  const [glossaryOpen, setGlossaryOpen] = useState(false)
  const [mindMapOpen, setMindMapOpen] = useState(false)
  const [shortcutsOpen, setShortcutsOpen] = useState(false)
  const [moveModalOpen, setMoveModalOpen] = useState(false)
  const [toolbarCollapsed, setToolbarCollapsed] = useState(false)
  const [pendingMoves, setPendingMoves] = useState<MoveOperation[]>([])
  const [summaryIndex, setSummaryIndex] = useState<Map<string, { summary?: string; lastIndexed?: string }>>(
    () => new Map()
  )
  const [tagsIndex, setTagsIndex] = useState<TagsIndex>({ tags: [], subjects: [], topics: [] })
  const [searchResults, setSearchResults] = useState<CodexSearchResult[]>([])
  const [searchLoading, setSearchLoading] = useState(false)
  const [searchError, setSearchError] = useState<string | null>(null)
  const [semanticEnabled, setSemanticEnabled] = useState(false)
  const [semanticSupported, setSemanticSupported] = useState(false)
  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('')
  const [searchQuery, setSearchQuery] = useState('')
  const [graphqlAvailable, setGraphqlAvailable] = useState(true)
  const [searchIndexAvailable, setSearchIndexAvailable] = useState(true)
  const [semanticStatus, setSemanticStatus] = useState<'ready' | 'degraded' | 'offline'>('ready')
  const [metadataPanelSize, setMetadataPanelSize] = useState<'s' | 'm' | 'l'>(preferences.metadataPanelSize ?? 's')
  const [activeHeadingSlug, setActiveHeadingSlug] = useState<string | null>(null)
  const [pluginCommands, setPluginCommands] = useState<typeof pluginUIRegistry.allCommands>([])
  const [isSavingMetadata, setIsSavingMetadata] = useState(false)
  const [lastSaveResult, setLastSaveResult] = useState<SaveResult | null>(null)
  // Track original metadata to compute diff for GitHub PRs
  const [originalFileMetadata, setOriginalFileMetadata] = useState<StrandMetadata>({})

  // Responsive layout
  const layout = useResponsiveLayout({
    onLayoutChange: (newLayout) => {
      // When changing to mobile, close panels if both are open
      if (!newLayout.preset.canShowBothPanels && sidebarOpen && metaOpen) {
        setMetaOpen(false)
      }
    }
  })

  // Knowledge tree
  const {
    tree: knowledgeTree,
    loading: knowledgeTreeLoading,
    error: knowledgeTreeError,
    totalStrands: totalTreeStrands,
    totalWeaves: totalTreeWeaves,
    totalLooms: totalTreeLooms,
    graphqlAvailable: githubGraphqlAvailable,
    resolvedBranch,
  } = useGithubTree()
  const activeBranchRef = useRef(REPO_CONFIG.BRANCH)

  // Update local GraphQL status when tree hook reports it
  useEffect(() => {
    setGraphqlAvailable(githubGraphqlAvailable)
  }, [githubGraphqlAvailable])

  useEffect(() => {
    if (resolvedBranch && activeBranchRef.current !== resolvedBranch) {
      activeBranchRef.current = resolvedBranch
      if (REPO_CONFIG.BRANCH !== resolvedBranch) {
        REPO_CONFIG.BRANCH = resolvedBranch
      }
    }
  }, [resolvedBranch])

  // Bookmarks and history
  const {
    bookmarks,
    history,
    isBookmarked,
    toggleBookmark,
    recordView,
    removeBookmark,
    removeFromHistory,
    clearAllBookmarks,
    clearAllHistory,
  } = useBookmarks()

  // Multi-selection for sidebar tree
  const treeSelection = useTreeSelection()

  // Toast notifications (must be before jobQueue which uses it)
  const toast = useToast()

  // Background job queue
  const jobQueue = useJobQueue({
    autoInit: true,
    onJobComplete: (job) => {
      toast.jobCompleted(JOB_TYPE_LABELS[job.type], 
        typeof job.result === 'object' && job.result && 'count' in job.result 
          ? (job.result as { count: number }).count 
          : undefined
      )
    },
    onJobFailed: (job) => {
      toast.jobFailed(JOB_TYPE_LABELS[job.type], job.error || 'Unknown error')
    },
  })

  // Feature flags for gated features
  const { flags: featureFlags, isEnabled } = useFeatureFlags()
  
  // Generate random facts for the welcome stats based on activity
  // Includes study encouragement when users browse but don't study (if feature enabled)
  const randomFacts = useMemo(() => {
    return getDailyFacts({
      history,
      totalStrands: totalTreeStrands,
      featureFlags: {
        enableFlashcards: featureFlags.enableFlashcards,
        enableQuizzes: featureFlags.enableQuizzes,
      },
      // Note: studyStats would be passed here when Learning Studio tracking is implemented
    })
  }, [history, totalTreeStrands, featureFlags.enableFlashcards, featureFlags.enableQuizzes])

  // User preferences
  // Apply preferences
  useEffect(() => {
    setSidebarMode(preferences.defaultSidebarMode)
  }, [preferences.defaultSidebarMode])

  useEffect(() => {
    setMetadataPanelSize(preferences.metadataPanelSize ?? 's')
  }, [preferences.metadataPanelSize])

  // Panel toggle handlers that respect mobile constraints
  const handleToggleSidebar = useCallback((forceState?: boolean) => {
    const newState = forceState !== undefined ? forceState : !sidebarOpen
    setSidebarOpen(newState)
    // On mobile, close right panel when opening left sidebar
    if (newState && !layout.preset.canShowBothPanels) {
      setMetaOpen(false)
    }
  }, [sidebarOpen, layout.preset.canShowBothPanels])

  const handleToggleMetaPanel = useCallback((forceState?: boolean) => {
    const newState = forceState !== undefined ? forceState : !metaOpen
    setMetaOpen(newState)
    // On mobile, close left sidebar when opening right panel
    if (newState && !layout.preset.canShowBothPanels) {
      setSidebarOpen(false)
    }
  }, [metaOpen, layout.preset.canShowBothPanels])

  // Keyboard shortcuts
  useCodexHotkeys({
    onToggleMeta: () => handleToggleMetaPanel(),
    onFocusSearch: () => {
      const input = document.getElementById('codex-search-input') as HTMLInputElement | null
      input?.focus()
      // On mobile, open sidebar to show search
      if (layout.isMobile) {
        handleToggleSidebar(true)
      }
    },
    onGoHome: () => { window.location.href = '/codex/' },
    onToggleSidebar: () => handleToggleSidebar(),
    onToggleBookmarks: () => setBookmarksOpen((v) => !v),
    onOpenPreferences: () => setPreferencesOpen(true),
    onToggleHelp: () => setHelpOpen((v) => !v),
    onToggleEdit: selectedFile ? () => setEditorOpen((v) => !v) : undefined,
    onToggleQA: () => setQAOpen((v) => !v),
    onToggleShortcuts: () => setShortcutsOpen((v) => !v),
  }, pluginCommands.filter(({ pluginId }) => quarryPluginManager.isEnabled(pluginId)))

  // Mobile swipe gestures
  useSwipeGesture({
    onSwipeRight: () => {
      if (window.innerWidth < 768 && !sidebarOpen) {
        setSidebarOpen(true)
      }
    },
    onSwipeLeft: () => {
      if (window.innerWidth < 768) {
        if (sidebarOpen) {
          setSidebarOpen(false)
        } else if (!metaOpen) {
          setMetaOpen(true)
        }
      }
    },
    onSwipeDown: () => {
      // Close any open modals on swipe down
      if (window.innerWidth < 768) {
        if (qaOpen) setQAOpen(false)
        else if (editorOpen) setEditorOpen(false)
        else if (graphOpen) setGraphOpen(false)
        else if (bookmarksOpen) setBookmarksOpen(false)
        else if (preferencesOpen) setPreferencesOpen(false)
        else if (helpOpen) setHelpOpen(false)
      }
    },
    threshold: 100,
  })

  // Text-to-Speech
  // Wrapped in useMemo to prevent TDZ errors during SSR/initial render
  const tts = useTextToSpeech()
  
  // Apply saved TTS preferences when voices are loaded (run once when voices become available)
  const ttsInitializedRef = useRef(false)
  useEffect(() => {
    if (ttsInitializedRef.current) return
    if (!tts.isSupported || tts.availableVoices.length === 0) return
    
    ttsInitializedRef.current = true
    const savedTTS = preferences.tts
    if (!savedTTS) return
    
    // Apply saved voice
    if (savedTTS.voiceURI) {
      const voice = tts.availableVoices.find(v => v.voiceURI === savedTTS.voiceURI)
      if (voice) tts.setVoice(voice)
    }
    
    // Apply saved rate, volume, pitch
    if (savedTTS.rate !== undefined) tts.setRate(savedTTS.rate)
    if (savedTTS.volume !== undefined) tts.setVolume(savedTTS.volume)
    if (savedTTS.pitch !== undefined) tts.setPitch(savedTTS.pitch)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [tts.isSupported, tts.availableVoices.length])

  // Quarry Plugin System: Set up viewer hooks
  useEffect(() => {
    setViewerHooks({
      navigateTo: (path: string) => {
        fetchContents(path)
        if (mode === 'page') {
          saveLastViewedLocation(path)
        }
      },
      openFile: async (path: string) => {
        const file = files.find(f => f.path === path)
        if (file && file.type === 'file') {
          await fetchFileContent(file)
        }
      },
      goBack: () => {
        if (typeof window !== 'undefined' && window.history.length > 1) {
          window.history.back()
        }
      },
      goForward: () => {
        if (typeof window !== 'undefined') {
          window.history.forward()
        }
      },
      getContent: () => fileContent,
      getMetadata: () => fileMetadata,
      getKnowledgeTree: () => knowledgeTree,
      expandNode: (path: string) => {
        setExpandedTreePaths(prev => new Set([...prev, path]))
        pluginEvents.emit('tree:expand', { path })
      },
      collapseNode: (path: string) => {
        setExpandedTreePaths(prev => {
          const next = new Set(prev)
          next.delete(path)
          return next
        })
        pluginEvents.emit('tree:collapse', { path })
      },
      search: async (query: string) => {
        try {
          const engine = getSearchEngine()
          const results = await engine.search(query, { limit: 20 })
          return results.map(r => ({
            path: r.path,
            name: r.title,
            score: r.combinedScore
          }))
        } catch {
          return []
        }
      },
      showNotice: (message: string, type = 'info' as const, timeout?: number) => {
        // Use dedicated methods for success, error, info; showToast for warning
        if (type === 'success') {
          toast.success(message)
        } else if (type === 'error') {
          toast.error(message)
        } else if (type === 'warning') {
          toast.showToast(message, 'warning', timeout)
        } else {
          toast.info(message)
        }
      },
      showModal: async (options) => {
        return new Promise((resolve) => {
          // For now, use a simple confirm dialog
          // TODO: Implement proper modal system for plugins
          const message = options.content?.toString() || options.title
          const result = window.confirm(message)
          resolve(result)
        })
      },
      getCurrentFile: () => selectedFile ? {
        path: selectedFile.path,
        name: selectedFile.name,
        content: fileContent
      } : null,
      getCurrentPath: () => currentPath,
      getTheme: () => ({
        theme: preferences.theme,
        isDark: preferences.theme.includes('dark')
      }),
    })

    return () => {
      clearViewerHooks()
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedFile, fileContent, fileMetadata, knowledgeTree, expandedTreePaths, currentPath, preferences.theme, files, mode, toast])
  // Note: fetchContents & fetchFileContent omitted from deps - defined later as stable useCallbacks

  // Quarry Plugin System: Emit events for file open/close
  useEffect(() => {
    if (selectedFile) {
      pluginEvents.emit('file:open', {
        path: selectedFile.path,
        name: selectedFile.name
      })

      return () => {
        pluginEvents.emit('file:close', {
          path: selectedFile.path
        })
      }
    }
  }, [selectedFile])

  // Quarry Plugin System: Emit theme change events
  useEffect(() => {
    pluginEvents.emit('theme:change', {
      theme: preferences.theme,
      isDark: preferences.theme.includes('dark')
    })
  }, [preferences.theme])

  // Quarry Plugin System: Emit sidebar toggle events
  useEffect(() => {
    pluginEvents.emit('sidebar:toggle', {
      open: sidebarOpen
    })
  }, [sidebarOpen])

  // Quarry Plugin System: Emit sidebar mode change events
  useEffect(() => {
    pluginEvents.emit('sidebar:mode', {
      mode: sidebarMode
    })
  }, [sidebarMode])

  // Quarry Plugin System: Emit navigation change events
  const prevPathRef = useRef<string>('')
  useEffect(() => {
    if (currentPath !== prevPathRef.current) {
      const oldPath = prevPathRef.current
      prevPathRef.current = currentPath
      if (oldPath !== '') { // Don't emit on initial mount
        pluginEvents.emit('navigation:change', {
          from: oldPath,
          to: currentPath
        })
      }
    }
  }, [currentPath])

  // Quarry Plugin System: Subscribe to plugin commands for keyboard shortcuts
  useEffect(() => {
    setPluginCommands(pluginUIRegistry.allCommands)
    const unsubscribe = pluginUIRegistry.onChange(() => {
      setPluginCommands([...pluginUIRegistry.allCommands])
    })
    return unsubscribe
  }, [])

  // PWA

  // Speak current file content
  const handleReadAloud = useCallback(() => {
    // Defensive check: tts may not be fully initialized on first render
    if (!tts || !fileContent) return
    if (typeof tts.speak === 'function') {
      tts.speak(fileContent)
    }
  }, [fileContent, tts])

  /**
   * Update URL when navigation changes (page mode only)
   * Uses clean SEO-friendly URLs like /codex/weaves/topic/strand-name
   * 
   * Note: Uses history.replaceState for URL updates without page reload,
   * since static export doesn't support Next.js RSC client navigation.
   */
  const updateURL = useCallback(
    (path: string, file?: string) => {
      if (mode === 'page') {
        // Use clean URLs for SEO: /codex/weaves/topic/strand-name
        // Priority: file path > directory path
        const targetPath = file || path
        if (targetPath) {
          // Remove .md extension for clean URLs
          const cleanPath = targetPath.replace(/\.md$/, '')
          const cleanUrl = `/codex/${cleanPath}/` // trailing slash for static export
          
          // Use replaceState to update URL without triggering navigation
          // This avoids RSC fetch issues with static export
          if (typeof window !== 'undefined' && window.location.pathname !== cleanUrl) {
            window.history.replaceState(null, '', cleanUrl)
          }
        }
      }
    },
    [mode]
  )

  /**
   * Load pre-computed Codex index (codex-index.json) for extractive summaries.
   * This file is generated by the Codex auto-indexer in GitHub Actions and
   * cached in SQLite based on content hash, so we only fetch a single JSON
   * blob here and reuse it for all strands.
   */
  useEffect(() => {
    let cancelled = false

    const fetchSummaryIndex = async () => {
      try {
        const indexUrl = API_ENDPOINTS.raw('codex-index.json', activeBranchRef.current)
        const response = await fetch(indexUrl)
        if (!response.ok) {
          // 404 is expected for non-Quarry Codex repos or when index isn't built yet
          if (!cancelled) setSearchIndexAvailable(false)
          return
        }

        const payload = (await response.json()) as unknown
        if (!Array.isArray(payload)) return

        const entries = payload as SummaryIndexEntry[]
        const map = new Map<string, { summary?: string; lastIndexed?: string }>()
        const fullMap = new Map<string, { metadata?: StrandMetadata & { autoGenerated?: Record<string, unknown> } }>()
        
        // Build tags index
        const tagMap = new Map<string, { count: number; paths: string[] }>()
        const subjectMap = new Map<string, { count: number; paths: string[] }>()
        const topicMap = new Map<string, { count: number; paths: string[] }>()
        
        entries.forEach((entry) => {
          if (!entry?.path) return
          const metadata = entry.metadata || {}
          const auto = metadata.autoGenerated as StrandMetadata['autoGenerated'] || {}
          map.set(entry.path, {
            summary: metadata.summary,
            lastIndexed: auto?.lastIndexed,
          })
          // Store full metadata for merging with frontmatter
          fullMap.set(entry.path, { metadata })
          
          // Extract tags
          const rawTags = metadata.tags
          const tags = Array.isArray(rawTags) ? rawTags : typeof rawTags === 'string' ? [rawTags] : []
          tags.forEach((tag) => {
            const normalizedTag = String(tag).trim().toLowerCase()
            if (!normalizedTag) return
            const existing = tagMap.get(normalizedTag) || { count: 0, paths: [] }
            existing.count++
            existing.paths.push(entry.path!)
            tagMap.set(normalizedTag, existing)
          })
          
          // Extract taxonomy subjects (from frontmatter or auto-generated)
          // Handle both singular (subject) and plural (subjects) forms
          const rawSubjects = metadata.taxonomy?.subjects || (metadata.taxonomy as any)?.subject || auto?.subjects || []
          const subjects = Array.isArray(rawSubjects) ? rawSubjects : []
          subjects.forEach((subject: string) => {
            const normalized = String(subject).trim().toLowerCase()
            if (!normalized) return
            const existing = subjectMap.get(normalized) || { count: 0, paths: [] }
            existing.count++
            existing.paths.push(entry.path!)
            subjectMap.set(normalized, existing)
          })
          
          // Extract taxonomy topics (from frontmatter or auto-generated)
          // Handle both singular (topic) and plural (topics) forms
          const rawTopics = metadata.taxonomy?.topics || (metadata.taxonomy as any)?.topic || auto?.topics || []
          const topics = Array.isArray(rawTopics) ? rawTopics : []
          topics.forEach((topic: string) => {
            const normalized = String(topic).trim().toLowerCase()
            if (!normalized) return
            const existing = topicMap.get(normalized) || { count: 0, paths: [] }
            existing.count++
            existing.paths.push(entry.path!)
            topicMap.set(normalized, existing)
          })
        })
        
        // Convert maps to arrays for TagsIndex
        const tagsArr: TagIndexEntry[] = Array.from(tagMap.entries()).map(([name, data]) => ({
          name,
          count: data.count,
          paths: data.paths,
        }))
        const subjectsArr: TagIndexEntry[] = Array.from(subjectMap.entries()).map(([name, data]) => ({
          name,
          count: data.count,
          paths: data.paths,
        }))
        const topicsArr: TagIndexEntry[] = Array.from(topicMap.entries()).map(([name, data]) => ({
          name,
          count: data.count,
          paths: data.paths,
        }))

        if (!cancelled) {
          setSummaryIndex(map)
          setFullIndexMap(fullMap)
          setTagsIndex({ tags: tagsArr, subjects: subjectsArr, topics: topicsArr })
          setSearchIndexAvailable(true)
          
          // Debug: log index loading
          if (process.env.NODE_ENV === 'development') {
            console.debug('[CodexViewer] Index loaded: fullIndexMap size:', fullMap.size)
            console.debug('[CodexViewer] Sample paths:', Array.from(fullMap.keys()).slice(0, 5))
            console.debug('[CodexViewer] Subjects count:', subjectsArr.length)
            console.debug('[CodexViewer] Topics count:', topicsArr.length)
          }
        }
      } catch (err) {
        if (!cancelled) setSearchIndexAvailable(false)
      }
    }

    fetchSummaryIndex()

    return () => {
      cancelled = true
    }
  }, [])
  
  // Re-merge metadata when index loads (fixes race condition)
  useEffect(() => {
    if (fullIndexMap.size === 0 || !selectedFile || !fileContent) return
    
    if (isMarkdownFile(selectedFile.name)) {
      const indexEntry = fullIndexMap.get(selectedFile.path)
      const autoGenerated = indexEntry?.metadata?.autoGenerated as Record<string, unknown> | undefined
      
      const frontmatter = parseWikiMetadata(fileContent)
      // Handle both singular (subject/topic) and plural (subjects/topics) forms from frontmatter
      // OpenStrand schema uses singular form (subject, topic) while the UI expects plural (subjects, topics)
      const fmSubjects = frontmatter.taxonomy?.subjects || (frontmatter.taxonomy as any)?.subject || []
      const fmTopics = frontmatter.taxonomy?.topics || (frontmatter.taxonomy as any)?.topic || []
      const fmTags = frontmatter.tags || (frontmatter.taxonomy as any)?.subtopic || []
      
      const mergedMetadata: StrandMetadata = {
        ...frontmatter,
        // Normalize tags from various sources
        tags: Array.isArray(fmTags) ? fmTags : typeof fmTags === 'string' ? fmTags.split(',').map(t => t.trim()) : [],
        taxonomy: {
          ...frontmatter.taxonomy,
          subjects: (Array.isArray(fmSubjects) && fmSubjects.length > 0)
            ? fmSubjects 
            : (autoGenerated?.subjects as string[] || []),
          topics: (Array.isArray(fmTopics) && fmTopics.length > 0)
            ? fmTopics 
            : (autoGenerated?.topics as string[] || []),
        },
        autoGenerated: autoGenerated as StrandMetadata['autoGenerated'],
      }
      setFileMetadata(mergedMetadata)
    }
  }, [fullIndexMap, selectedFile, fileContent])

  // Debounce search query for advanced ranking engines
  useEffect(() => {
    const handle = window.setTimeout(() => {
      setDebouncedSearchQuery(searchQuery.trim())
    }, 250)
    return () => window.clearTimeout(handle)
  }, [searchQuery])

  const handleSearchQueryChange = useCallback(
    (value: string) => {
      setSearchQueryInput(value)
      setSearchQuery(value)
    },
    [setSearchQueryInput],
  )

  const handleSearchReset = useCallback(() => {
    resetSearchFilters()
    setSearchQuery('')
    setSemanticEnabled(false)
  }, [resetSearchFilters])

  // Reset to home state - clear everything and go back to welcome screen
  const handleResetToHome = useCallback(() => {
    // Clear selected file to show welcome screen
    setSelectedFile(null)
    // Reset navigation to root
    setCurrentPath('')
    // Clear search
    resetSearchFilters()
    setSearchQuery('')
    setSemanticEnabled(false)
    // Clear multi-selection
    treeSelection.clearSelection()
    // Reset advanced filters
    resetAdvancedFilters()
  }, [resetSearchFilters, treeSelection, resetAdvancedFilters])

  // Handle publishing content from inline editor
  const handlePublishContent = useCallback(
    async (content: string, metadata: StrandMetadata) => {
      if (selectedFile) {
        setEditorDraft({ content, metadata })
        setEditorOpen(true)
      }
    },
    [selectedFile]
  )

  /**
   * Handle metadata save from the MetadataEditor
   *
   * Saves to multiple targets based on configuration:
   * 1. Always: Local database (IndexedDB via SQLite)
   * 2. If vault configured: Vault folder (filesystem)
   * 3. If GitHub mode with PAT: Create Pull Request
   *
   * Then triggers lazy async re-indexing for search updates.
   */
  const handleMetadataSave = useCallback(async (updatedMetadata: StrandMetadata) => {
    if (!selectedFile) return

    setIsSavingMetadata(true)
    setLastSaveResult(null)

    try {
      // Extract content body (without frontmatter) from fileContent
      const contentBody = fileContent.replace(/^---[\s\S]*?---\n*/, '')

      // Build content source config based on current mode
      // For now, use 'sqlite' as default since we're always saving to IndexedDB
      const contentSource = {
        type: 'sqlite' as const,
        isOnline: navigator.onLine,
        lastSync: null,
        pendingChanges: 0,
      }

      // Check for GitHub PAT in preferences
      const githubPat = preferences.githubPAT?.trim()
      const hasGitHubPat = Boolean(githubPat && githubPat.length > 0)

      // Save to all available targets
      const result = await saveStrandMetadata({
        strand: updatedMetadata,
        originalStrand: originalFileMetadata,
        contentBody,
        strandPath: selectedFile.path,
        contentSource,
        // vaultHandle would come from preferences if vault is configured
        // For now, we'll skip vault sync until vault is properly integrated
        vaultHandle: undefined,
        // GitHub config for PR creation
        githubConfig: hasGitHubPat ? {
          owner: REPO_CONFIG.OWNER,
          repo: REPO_CONFIG.NAME,
          branch: REPO_CONFIG.BRANCH,
          pat: githubPat,
        } : undefined,
      })

      setLastSaveResult(result)

      // Show success toast with save targets
      if (result.savedTo.length > 0) {
        const targetsText = result.savedTo.join(', ')
        if (result.prUrl) {
          toast.success(`Saved to ${targetsText}. PR created!`)
        } else {
          toast.success(`Saved to ${targetsText}`)
        }
      }

      // Show errors if any targets failed
      if (result.errors.length > 0) {
        const errorTargets = result.errors.map(e => e.target).join(', ')
        toast.error(`Failed to save to: ${errorTargets}`)
      }

      // Update local state with the new metadata
      setFileMetadata(updatedMetadata)

      // Trigger lazy async re-indexing
      // This updates search indexes in the background without blocking
      await reindexStrandMetadata(selectedFile.path, updatedMetadata, {
        reindexBlocks: false, // Skip heavy block processing for now
        updateEmbeddings: false, // Skip embeddings for now
        runTagBubbling: false, // Skip tag bubbling for now
        priority: 'deferred', // Run in background job queue
      })

    } catch (error) {
      console.error('[CodexViewer] Metadata save failed:', error)
      toast.error(error instanceof Error ? error.message : 'Failed to save metadata')
    } finally {
      setIsSavingMetadata(false)
    }
  }, [selectedFile, fileContent, originalFileMetadata, preferences.githubPAT, toast])

  const handleMetadataPanelSizeChange = useCallback(
    (size: 's' | 'm' | 'l') => {
      setMetadataPanelSize(size)
      updateMetadataPanelSize(size)
    },
    [updateMetadataPanelSize]
  )

  // Handle file move from drag-and-drop - adds to pending moves (batch mode)
  const handleMoveComplete = useCallback((operations: MoveOperation[]) => {
    setPendingMoves(prev => [...prev, ...operations])
    // Show the modal after a brief delay to let user see multiple moves
    // accumulated if they're moving multiple files quickly
    setTimeout(() => {
      setMoveModalOpen(true)
    }, 300)
  }, [])

  // Handle publishing moves to GitHub
  const handlePublishMoves = useCallback(async (operations: MoveOperation[]) => {
    // Get GitHub PAT from localStorage (set in settings)
    const githubPAT = localStorage.getItem('openstrand_github_pat')
    if (!githubPAT) {
      throw new Error('GitHub Personal Access Token not configured. Please add it in Settings.')
    }

    const response = await fetch('/api/github/move-files', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${githubPAT}`,
      },
      body: JSON.stringify({
        operations,
        branchName: `codex-move-${Date.now()}`,
        commitMessage: `chore: reorganize ${operations.length} file${operations.length > 1 ? 's' : ''}`,
        prTitle: `Reorganize Codex files (${operations.length} move${operations.length > 1 ? 's' : ''})`,
        prBody: 'File reorganization from FABRIC Codex drag-and-drop interface.',
      }),
    })

    if (!response.ok) {
      const error = await response.json()
      throw new Error(error.error || 'Failed to create PR')
    }

    const result = await response.json()
    // Clear pending moves after successful publish
    setPendingMoves([])
    setMoveModalOpen(false)

    // Open PR in new tab
    if (result.prUrl) {
      window.open(result.prUrl, '_blank')
    }
  }, [])

  // Clear all pending moves
  const handleClearMoves = useCallback(() => {
    setPendingMoves([])
    setMoveModalOpen(false)
  }, [])

  // Remove single move operation
  const handleRemoveMove = useCallback((index: number) => {
    setPendingMoves(prev => prev.filter((_, i) => i !== index))
  }, [])

  // Handle tag/category click - navigate to filtered view
  const handleTagClick = useCallback(
    (type: 'tag' | 'subject' | 'topic', value: string) => {
      // Navigate to the tag page with the selected filter
      const baseUrl = '/codex/browse'
      const params = new URLSearchParams()
      params.set(type, value)
      router.push(`${baseUrl}?${params.toString()}`)
    },
    [router]
  )

  // Handle navigating to a heading in the document (for TOC outline)
  const handleNavigateToHeading = useCallback((slug: string) => {
    // Find the heading element by slug/id and scroll to it
    const headingEl = document.querySelector(`[id="${slug}"], [data-heading-slug="${slug}"]`)
    if (headingEl) {
      headingEl.scrollIntoView({ behavior: 'smooth', block: 'start' })
    } else {
      // Fallback: try to find by text content
      const contentEl = document.querySelector('.codex-content-scroll')
      if (contentEl) {
        const headings = contentEl.querySelectorAll('h1, h2, h3, h4, h5, h6')
        for (const heading of headings) {
          const text = heading.textContent?.toLowerCase().replace(/[^\w\s-]/g, '').replace(/\s+/g, '-') || ''
          if (text === slug || text.includes(slug)) {
            heading.scrollIntoView({ behavior: 'smooth', block: 'start' })
            break
          }
        }
      }
    }
  }, [])

  // Execute BM25 / semantic search when query changes
  useEffect(() => {
    let cancelled = false
    const query = debouncedSearchQuery

    if (!query) {
      setSearchResults([])
      setSearchError(null)
      setSearchLoading(false)
      return () => {
        cancelled = true
      }
    }

    const runSearch = async () => {
      setSearchLoading(true)
      setSearchError(null)
      try {
        const engine = getSearchEngine()
        const results = await engine.search(query, {
          limit: 25,
          semantic: semanticEnabled,
        })
        if (!cancelled) {
          setSemanticSupported(engine.canUseSemantic())
          setSearchResults(results)
          // Quarry Plugin System: Emit search event
          pluginEvents.emit('search:query', {
            query,
            results: results.length
          })
        }
      } catch (err) {
        console.error('Advanced search error:', err)
        if (!cancelled) {
          setSearchError('Advanced search is temporarily unavailable.')
          setSearchResults([])
          setSemanticSupported(false)
        }
      } finally {
        if (!cancelled) {
          setSearchLoading(false)
        }
      }
    }

    runSearch()

    return () => {
      cancelled = true
    }
  }, [debouncedSearchQuery, semanticEnabled])

  /**
   * Fetch directory contents from GitHub API
   */
  const fetchContents = useCallback(
    async (path: string = '', autoSelectFile: boolean = true): Promise<GitHubFile[]> => {
      setLoading(true)
      setError(null)
      const branchCandidates = Array.from(
        new Set(
          [resolvedBranch, activeBranchRef.current, 'master', 'main', REPO_CONFIG.BRANCH].filter(
            (value): value is string => Boolean(value && value.length)
          )
        )
      )
      let lastError: Error | null = null

      try {
        for (const branch of branchCandidates) {
      try {
            const response = await fetch(API_ENDPOINTS.contents(path, branch))
        if (!response.ok) {
              throw new Error(`Failed to fetch: ${response.status} ${response.statusText}`)
        }

        const data = await response.json()
        const filtered = data.filter((item: GitHubFile) => !shouldIgnorePath(item.name))
            const sortedData = filtered.sort((a: GitHubFile, b: GitHubFile) => {
          if (a.type !== b.type) return a.type === 'dir' ? -1 : 1
          return a.name.localeCompare(b.name)
        })

        setFiles(sortedData)
        setCurrentPath(path)
        updateURL(path)
            if (branch && branch !== REPO_CONFIG.BRANCH) {
              REPO_CONFIG.BRANCH = branch
            }
            if (activeBranchRef.current !== branch) {
              activeBranchRef.current = branch
            }
            
            return sortedData
          } catch (err) {
            lastError = err instanceof Error ? err : new Error('Failed to fetch repository contents')
          }
        }

        throw lastError ?? new Error('Failed to fetch repository contents')
      } catch (err) {
        console.error('Error fetching contents:', err)
        setError(err instanceof Error ? err.message : 'Failed to fetch repository contents')
        return []
      } finally {
        setLoading(false)
      }
    },
    [resolvedBranch, updateURL]
  )

  /**
   * Fetch file content from GitHub with optional SQL-backed cache.
   */
  const fetchFileContent = useCallback(
    async (file: GitHubFile) => {
      if (file.type !== 'file' || !file.download_url) return

      setLoading(true)
      setError(null)

      try {
        const cacheKey = file.path

        // Try cache first for instant load on repeat views.
        const cached = await getCachedStrand(cacheKey)
        let content = cached || ''

        if (!cached) {
          const response = await fetch(file.download_url)
          if (!response.ok) {
            throw new Error(`Failed to fetch file: ${response.statusText}`)
          }

          content = await response.text()
          // Store in SQL-backed cache (IndexedDB/sql.js in browser, memory in SSR)
          await setCachedStrand(cacheKey, content)
        }

        setFileContent(content)
        setSelectedFile(file)

        // Parse metadata and merge with auto-generated from index
        if (isMarkdownFile(file.name)) {
          const frontmatter = parseWikiMetadata(content)
          
          // Merge auto-generated metadata from index
          const indexEntry = fullIndexMap.get(file.path)
          const autoGenerated = indexEntry?.metadata?.autoGenerated as Record<string, unknown> | undefined
          
          // Debug: log index lookup
          if (process.env.NODE_ENV === 'development') {
            console.debug('[CodexViewer] Looking up index for path:', file.path)
            console.debug('[CodexViewer] Index entry found:', !!indexEntry)
            console.debug('[CodexViewer] autoGenerated:', autoGenerated)
            console.debug('[CodexViewer] fullIndexMap size:', fullIndexMap.size)
          }
          
          // Merge taxonomy: frontmatter takes priority, but add auto-generated if missing
          // Handle both singular (subject/topic) and plural (subjects/topics) forms from frontmatter
          // OpenStrand schema uses singular form (subject, topic) while the UI expects plural (subjects, topics)
          const fmSubjects = frontmatter.taxonomy?.subjects || (frontmatter.taxonomy as any)?.subject || []
          const fmTopics = frontmatter.taxonomy?.topics || (frontmatter.taxonomy as any)?.topic || []
          const fmTags = frontmatter.tags || (frontmatter.taxonomy as any)?.subtopic || []
          
          const mergedMetadata: StrandMetadata = {
            ...frontmatter,
            // Normalize tags from various sources (tags field, or subtopic from taxonomy)
            tags: Array.isArray(fmTags) ? fmTags : typeof fmTags === 'string' ? fmTags.split(',').map(t => t.trim()) : [],
            taxonomy: {
              ...frontmatter.taxonomy,
              subjects: (Array.isArray(fmSubjects) && fmSubjects.length > 0)
                ? fmSubjects 
                : (autoGenerated?.subjects as string[] || []),
              topics: (Array.isArray(fmTopics) && fmTopics.length > 0)
                ? fmTopics 
                : (autoGenerated?.topics as string[] || []),
            },
            // Add autoGenerated to metadata for display
            autoGenerated: autoGenerated as StrandMetadata['autoGenerated'],
          }
          
          setFileMetadata(mergedMetadata)
          // Also store original for computing diff when saving
          setOriginalFileMetadata(mergedMetadata)
        }

        // Record view in history
        recordView(file.path, file.name)

        updateURL(currentPath, file.path)
      } catch (err) {
        console.error('Error fetching file content:', err)
        setError(err instanceof Error ? err.message : 'Failed to fetch file content')
      } finally {
        setLoading(false)
      }
    },
    [currentPath, updateURL, recordView, fullIndexMap]
  )

  /**
   * Handle file/directory click
   */
  const handleFileClick = (file: GitHubFile) => {
    if (file.type === 'dir') {
      fetchContents(file.path)
      // Save last viewed directory
      if (mode === 'page') {
        saveLastViewedLocation(file.path)
      }
    } else {
      fetchFileContent(file)
      // Save last viewed file
      if (mode === 'page') {
        saveLastViewedLocation(currentPath, file.path)
      }
    }
  }

  /**
   * Toggle tree path expansion
   */
  const toggleTreePath = (path: string) => {
    setExpandedTreePaths((prev) => {
      const next = new Set(prev)
      if (next.has(path)) {
        next.delete(path)
      } else {
        next.add(path)
      }
      return next
    })
  }

  /**
   * Get all expandable paths from the knowledge tree
   */
  const getAllExpandablePaths = useCallback((): string[] => {
    const paths: string[] = []
    const collectPaths = (nodes: typeof knowledgeTree) => {
      for (const node of nodes) {
        if (node.type === 'dir' || node.children?.length) {
          paths.push(node.path)
          if (node.children) {
            collectPaths(node.children)
          }
        }
      }
    }
    collectPaths(knowledgeTree)
    return paths
  }, [knowledgeTree])

  /**
   * Expand all tree nodes
   */
  const handleExpandAll = useCallback(() => {
    const allPaths = getAllExpandablePaths()
    setExpandedTreePaths(new Set(allPaths))
  }, [getAllExpandablePaths])

  /**
   * Collapse all tree nodes
   */
  const handleCollapseAll = useCallback(() => {
    setExpandedTreePaths(new Set())
  }, [])

  /**
   * Check if all nodes are expanded
   */
  const isAllExpanded = useMemo(() => {
    const allPaths = getAllExpandablePaths()
    if (allPaths.length === 0) return false
    return allPaths.every(path => expandedTreePaths.has(path))
  }, [getAllExpandablePaths, expandedTreePaths])

  /**
   * Open file from knowledge tree
   */
  const openFileFromTree = useCallback(
    async (fullPath: string) => {
      const normalizedPath = fullPath.replace(/^\/+/, '')
      const segments = normalizedPath.split('/')
      const fileName = segments.pop() || normalizedPath
      const parentDir = segments.join('/')

      // Safety check: Only fetch if path looks like a file (has extension)
      // This prevents trying to fetch directories as raw files
      const hasExtension = /\.[a-zA-Z0-9]+$/.test(fileName)
      if (!hasExtension) {
        // This looks like a directory - navigate to it and auto-select a file
        const dirFiles = await fetchContents(normalizedPath, false)
        if (dirFiles.length > 0) {
          const readmeFile = dirFiles.find((f: GitHubFile) =>
            f.type === 'file' &&
            (f.name.toLowerCase() === 'readme.md' ||
             f.name.toLowerCase() === 'index.md' ||
             f.name.toLowerCase() === '_index.md')
          ) || dirFiles.find((f: GitHubFile) =>
            f.type === 'file' && f.name.endsWith('.md')
          )
          if (readmeFile) {
            await fetchFileContent(readmeFile)
          }
        }
        if (window.innerWidth < 768) {
          setSidebarOpen(false)
        }
        return
      }

      const filePayload: GitHubFile = {
        name: fileName,
        path: normalizedPath,
        type: 'file',
        sha: '',
        url: '',
        html_url: `https://github.com/${REPO_CONFIG.OWNER}/${REPO_CONFIG.NAME}/blob/${REPO_CONFIG.BRANCH}/${normalizedPath}`,
        download_url: API_ENDPOINTS.raw(normalizedPath, activeBranchRef.current),
      }

      if (parentDir !== currentPath) {
        await fetchContents(parentDir)
      }

      await fetchFileContent(filePayload)

      // Auto-close sidebar on mobile
      if (window.innerWidth < 768) {
        setSidebarOpen(false)
      }
    },
    [currentPath, fetchContents, fetchFileContent]
  )

  const handleOpenSearchResult = useCallback(
    (fullPath: string) => {
      openFileFromTree(fullPath)
    },
    [openFileFromTree],
  )

  /**
   * Navigate to a directory and auto-select a README/index file if present
   * Used for internal links and breadcrumb navigation
   */
  const navigateToDirectory = useCallback(
    async (path: string) => {
      const sortedData = await fetchContents(path, false)
      
      // Auto-select README or index file
      if (sortedData.length > 0) {
        const readmeFile = sortedData.find((f: GitHubFile) => 
          f.type === 'file' && 
          (f.name.toLowerCase() === 'readme.md' || 
           f.name.toLowerCase() === 'index.md' ||
           f.name.toLowerCase() === '_index.md')
        )
        // If no README, select first markdown file
        const firstMdFile = readmeFile || sortedData.find((f: GitHubFile) => 
          f.type === 'file' && f.name.endsWith('.md')
        )
        if (firstMdFile) {
          await fetchFileContent(firstMdFile)
        }
      }
      
      // Auto-close sidebar on mobile
      if (window.innerWidth < 768) {
        setSidebarOpen(false)
      }
    },
    [fetchContents, fetchFileContent]
  )

  /**
   * Browse a directory without auto-selecting a file
   * Used for Weave/Loom exploration where user wants to see folder contents
   * 
   * @remarks
   * - Keeps current sidebar mode (respects user's view preference)
   * - Filtering is applied automatically via useSearchFilter
   * - Expands the path in tree view for visibility
   */
  const browseDirectory = useCallback(
    async (path: string) => {
      await fetchContents(path, false)
      // Clear selected file to show the folder browser view
      setSelectedFile(null)
      setFileContent('')
      setFileMetadata({})
      
      // Expand the browsed path in tree view so user can see contents
      // (works regardless of current sidebar mode)
      setExpandedTreePaths(prev => {
        const newSet = new Set(prev)
        // Expand all parent paths up to the browsed path
        const segments = path.split('/')
        let currentPath = ''
        segments.forEach(segment => {
          currentPath = currentPath ? `${currentPath}/${segment}` : segment
          newSet.add(currentPath)
        })
        return newSet
      })
      
      // Keep sidebar open on mobile to show folder contents
      if (window.innerWidth < 768) {
        setSidebarOpen(true)
      }
    },
    [fetchContents]
  )

  // Load from URL params on mount and when URL changes
  const urlPath = searchParams.get('path') || ''
  const urlFile = searchParams.get('file') || ''
  
  useEffect(() => {
    if (isOpen && mode === 'page') {
      // Priority: URL params > last viewed > initial path
      let path = urlPath || ''
      let file = urlFile || ''

      // If file is provided but path is not, extract path from file
      if (file && !path) {
        // Extract directory path from file path (e.g., "weaves/frame/openstrand/architecture.md" -> "weaves/frame/openstrand")
        const lastSlash = file.lastIndexOf('/')
        if (lastSlash > 0) {
          path = file.substring(0, lastSlash)
        }
      }

      // If no URL params at all, try to load last viewed location or use initial props
      if (!urlPath && !urlFile) {
        // Check if we have initialFile from clean URL routing
        if (initialFile) {
          file = initialFile
          // Extract directory path from file path
          const lastSlash = initialFile.lastIndexOf('/')
          if (lastSlash > 0) {
            path = initialFile.substring(0, lastSlash)
          } else {
            path = initialPath || ''
          }
        } else if (initialPath) {
          // Use explicitly provided initial path (from URL routing)
          path = initialPath
        }
        // else: On homepage (/codex/), start with empty path (shows root)
        // Don't restore last viewed in page mode - let URL determine location
      }

      // Only fetch contents if the path has changed or we have no files
      if (path !== currentPath || files.length === 0) {
        fetchContents(path).then((newFiles) => {
          if (file && file !== selectedFile?.path) {
            const allFilesForSearch = newFiles && newFiles.length > 0 ? newFiles : files
            const targetFile = allFilesForSearch.find((f) => f.path === file)
            if (targetFile) {
              fetchFileContent(targetFile)
            } else if (allFilesForSearch.length > 0) {
              // Fallback: if requested file doesn't exist (e.g., weaves/frame.md),
              // try to find a README or index file in the directory
              const fallbackFile = allFilesForSearch.find((f: GitHubFile) =>
                f.type === 'file' &&
                (f.name.toLowerCase() === 'readme.md' ||
                 f.name.toLowerCase() === 'index.md' ||
                 f.name.toLowerCase() === '_index.md')
              ) || allFilesForSearch.find((f: GitHubFile) =>
                f.type === 'file' && f.name.endsWith('.md')
              )
              if (fallbackFile) {
                fetchFileContent(fallbackFile)
              }
              // If no markdown files, just show directory browser (no file selected)
            }
          }
        })
      } else if (file && file !== selectedFile?.path) {
        // Path hasn't changed, but file has, and we have files loaded
        const targetFile = files.find((f) => f.path === file)
        if (targetFile) {
          fetchFileContent(targetFile)
        } else if (files.length > 0) {
          // Fallback: try README/index file
          const fallbackFile = files.find((f: GitHubFile) =>
            f.type === 'file' &&
            (f.name.toLowerCase() === 'readme.md' ||
             f.name.toLowerCase() === 'index.md' ||
             f.name.toLowerCase() === '_index.md')
          ) || files.find((f: GitHubFile) =>
            f.type === 'file' && f.name.endsWith('.md')
          )
          if (fallbackFile) {
            fetchFileContent(fallbackFile)
          }
        }
      }
    } else if (isOpen && files.length === 0) {
      // Modal mode initial load
      fetchContents(initialPath)
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isOpen, mode, urlPath, urlFile, initialFile, initialPath])

  const isModal = mode === 'modal'

  if (!isOpen && isModal) return null

  const currentSummary =
    selectedFile && summaryIndex.size > 0 ? summaryIndex.get(selectedFile.path) ?? null : null
  const activeSearchQuery = searchQuery.trim()

  // Responsive right panel widths - More generous than left sidebar
  // S = compact, M = standard, L = expanded (larger than left sidebar)
  const rightPanelWidthClass =
    metadataPanelSize === 'm'
      ? 'md:w-[280px] lg:w-[340px] xl:w-[400px]'
      : metadataPanelSize === 'l'
        ? 'md:w-[340px] lg:w-[420px] xl:w-[500px]'
        : 'md:w-[240px] lg:w-[280px] xl:w-[320px]' // Small - compact sidebar

  const content = (
    <div className="quarry-codex-viewer flex-1 flex overflow-hidden pb-[60px] md:pb-0 min-h-0">
      {/* Mobile Sidebar Toggle - flush left edge tab when sidebar is closed */}
      {!sidebarOpen && (
        <button
          onClick={() => handleToggleSidebar(true)}
          className="md:hidden fixed left-0 top-1/3 z-30 py-4 px-1.5 rounded-r-xl bg-zinc-100/95 dark:bg-zinc-800/95 backdrop-blur-sm text-zinc-500 dark:text-zinc-400 active:bg-zinc-200 dark:active:bg-zinc-700 shadow-lg transition-all active:scale-95 border border-l-0 border-zinc-200 dark:border-zinc-700"
          aria-label="Open sidebar"
        >
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" className="overflow-visible">
            <path d="M9 6L15 12L9 18" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" />
          </svg>
        </button>
      )}
      
      {/* Metadata Toggle FAB (shows when panel closed on desktop, or when neither panel is open on mobile) */}
      <MetadataToggleFAB 
        isOpen={metaOpen} 
        onToggle={() => handleToggleMetaPanel(true)}
        theme={preferences.theme}
      />
      
      {/* Media Capture FAB - Opens radial menu for voice, camera, drawing */}
      <MediaCaptureFAB
        theme={preferences.theme}
        position="bottom-right"
        visible={!!selectedFile}
        onInsertImage={(url) => console.log('[MediaCapture] Image:', url)}
        onInsertAudio={(url) => console.log('[MediaCapture] Audio:', url)}
        onInsertDrawing={(url) => console.log('[MediaCapture] Drawing:', url)}
        onInsertCode={(lang) => console.log('[MediaCapture] Code:', lang)}
        onMediaCaptured={(asset) => {
          console.log('[MediaCapture] Asset captured:', asset)
          // TODO: Upload to repository and insert into content
        }}
      />

      {/* Floating Sidebar Collapse Toggle - Left sidebar */}
      {!layout.isMobile && (
        <SidebarCollapseToggle
          isOpen={sidebarOpen}
          onToggle={() => handleToggleSidebar()}
          side="left"
          theme={preferences.theme}
        />
      )}

      {/* Sidebar */}
      <CodexSidebar
        isOpen={sidebarOpen}
        onClose={() => handleToggleSidebar(false)}
        currentPath={currentPath}
        files={files}
        filteredFiles={filteredFiles}
        selectedFile={selectedFile}
        onFileClick={handleFileClick}
        onNavigate={navigateToDirectory}
        onBrowse={browseDirectory}
        mode={sidebarMode}
        onModeChange={setSidebarMode}
        knowledgeTree={knowledgeTree}
        knowledgeTreeLoading={knowledgeTreeLoading}
        knowledgeTreeError={knowledgeTreeError}
        totalTreeStrands={totalTreeStrands}
        totalTreeWeaves={totalTreeWeaves}
        totalTreeLooms={totalTreeLooms}
        expandedTreePaths={expandedTreePaths}
        onToggleTreePath={toggleTreePath}
        onOpenFileFromTree={openFileFromTree}
        loading={loading}
        error={error}
        searchOptions={searchOptions}
        onSearchQueryChange={handleSearchQueryChange}
        onToggleSearchNames={toggleSearchNames}
        onToggleSearchContent={toggleSearchContent}
        onToggleCaseSensitive={toggleCaseSensitive}
        onSetFilterScope={setFilterScope}
        onToggleHideEmptyFolders={toggleHideEmptyFolders}
        onSetRootScope={setRootScope}
        onResetSearch={handleSearchReset}
        onResetToHome={handleResetToHome}
        onOpenHelp={() => setHelpOpen(true)}
        onOpenBookmarks={() => setBookmarksOpen(true)}
        onOpenPreferences={() => setPreferencesOpen(true)}
        sidebarWidth={sidebarWidth}
        onSidebarWidthChange={setSidebarWidth}
        sidebarFontSize={sidebarFontSize}
        onSidebarFontSizeChange={setSidebarFontSize}
        onExpandAll={handleExpandAll}
        onCollapseAll={handleCollapseAll}
        isAllExpanded={isAllExpanded}
        theme={preferences.theme}
        tagsIndex={tagsIndex}
        onTagClick={handleTagClick}
        fileContent={fileContent}
        onNavigateToHeading={handleNavigateToHeading}
        activeHeadingSlug={activeHeadingSlug || undefined}
        onOpenGraph={() => setFabricGraphOpen(true)}
        onMoveComplete={handleMoveComplete}
        // Advanced filters
        advancedFilters={advancedFilters}
        onSetDateFilter={setDateFilter}
        onToggleTag={toggleTag}
        onSetSelectedTags={setSelectedTags}
        onSetTagMatchMode={setTagMatchMode}
        onToggleSubject={toggleSubject}
        onSetSelectedSubjects={setSelectedSubjects}
        onSetSelectedTopics={setSelectedTopics}
        onIncludePath={includePath}
        onResetAdvancedFilters={resetAdvancedFilters}
        dateIndex={dateIndex}
        metadataMap={metadataMap}
        activeAdvancedFilterCount={activeAdvancedFilterCount}
        hasAdvancedFilters={hasAdvancedFilters}
        hasHiddenItems={advancedFilters.excludedPaths.length > 0}
        // Multi-selection - always enabled, no toggle needed
        selectionMode={true}
        selectedPaths={treeSelection.selectedPaths}
        selectionStats={treeSelection.stats}
        onTogglePathSelection={treeSelection.togglePath}
        isPathSelected={treeSelection.isSelected}
        onSelectRecursive={treeSelection.selectRecursive}
        onClearSelection={treeSelection.clearSelection}
        onGetAllStrandPaths={() => treeSelection.getAllStrandPaths(knowledgeTree as any)}
        onGenerateFlashcards={(strandPaths) => {
          jobQueue.enqueueFlashcards(strandPaths)
          toast.jobStarted('Flashcard Generation', strandPaths.length)
        }}
        onGenerateGlossary={(strandPaths) => {
          jobQueue.enqueueGlossary(strandPaths)
          toast.jobStarted('Glossary Generation', strandPaths.length)
        }}
        onGenerateQuiz={(strandPaths) => {
          jobQueue.enqueueQuiz(strandPaths)
          toast.jobStarted('Quiz Generation', strandPaths.length)
        }}
      />

      {/* Main content area with toolbar and content */}
      <div className="flex-1 flex flex-col overflow-hidden min-h-0">
        {/* API Status Banner */}
        <ApiStatusBanner
          graphqlAvailable={graphqlAvailable}
          searchAvailable={searchIndexAvailable && semanticStatus === 'ready'}
          semanticStatus={semanticStatus}
          onOpenSettings={() => setSettingsOpen(true)}
        />

        {/* Toolbar with Logo - Single row, compact height */}
        <div className="px-2 border-b border-zinc-200 dark:border-obsidian-800 bg-white dark:bg-obsidian-950/50 backdrop-blur-sm">
          <div className="flex items-center gap-1">
            {/* Mobile: Brand logo (clickable to home) */}
            <div className="flex items-center md:hidden flex-shrink-0">
              <a
                href="/codex/"
                onClick={(e) => {
                  e.preventDefault()
                  // Reset everything and go to home
                  setSelectedFile(null)
                  setFileContent('')
                  setCurrentPath('')
                  setSearchQuery('')
                  setSidebarOpen(false)
                  setMetaOpen(false)
                  window.location.href = '/codex/'
                }}
                className="flex items-center"
                aria-label="Go to Codex home"
              >
                <QuarryBrand
                  size="sm"
                  showIcon={true}
                  compact={true}
                  linkToHome={false}
                  theme={preferences.theme}
                />
              </a>
            </div>

            {/* Toolbar - expands to fill remaining space */}
            <div className="flex-1 min-w-0">
              <CodexToolbar
            currentPath={currentPath}
            metaOpen={metaOpen}
            onToggleMeta={() => setMetaOpen((v) => !v)}
            currentFile={selectedFile ? { path: selectedFile.path, name: selectedFile.name } : null}
            isBookmarked={selectedFile ? isBookmarked(selectedFile.path) : false}
            onToggleBookmark={selectedFile ? () => toggleBookmark(selectedFile.path, selectedFile.name) : undefined}
            onOpenBookmarks={() => setBookmarksOpen(true)}
            onOpenPreferences={() => setPreferencesOpen(true)}
            onOpenHelp={() => setHelpOpen(true)}
            onOpenGraph={() => setGraphOpen(true)}
            onOpenTimeline={() => setTimelineOpen(true)}
            onOpenContribute={() => setContributeOpen(true)}
            onOpenEditor={() => {
              setEditorDraft(null)
              setEditorOpen(true)
            }}
            onOpenQA={() => setQAOpen(true)}
            onOpenFlashcards={() => setFlashcardsOpen(true)}
            onOpenGlossary={() => setGlossaryOpen(true)}
            onOpenMindMap={() => setMindMapOpen(true)}
            collapsed={toolbarCollapsed}
            onCollapseChange={setToolbarCollapsed}
            showCollapseToggle={true}
            ttsState={tts.state}
            ttsSettings={tts.settings}
            ttsVoices={tts.availableVoices}
            ttsSupported={tts.isSupported}
            ttsHasContent={!!fileContent && fileContent.trim().length > 0}
            onTTSPlay={handleReadAloud}
            onTTSPause={tts.pause}
            onTTSResume={tts.resume}
            onTTSStop={tts.stop}
            onTTSVolumeChange={tts.setVolume}
            onTTSRateChange={tts.setRate}
            onTTSPitchChange={tts.setPitch}
            onTTSVoiceChange={tts.setVoice}
            theme={preferences.theme}
          />
            </div>

            {/* Pending Moves Badge */}
            {pendingMoves.length > 0 && (
              <PendingMovesBadge
                count={pendingMoves.length}
                onClick={() => setMoveModalOpen(true)}
                isDark={preferences.theme?.includes('dark')}
              />
            )}
          </div>
        </div>
        {activeSearchQuery.length > 0 && (
          <SearchResultsPanel
            query={activeSearchQuery}
            results={searchResults}
            loading={searchLoading}
            error={searchError}
            semanticEnabled={semanticEnabled}
            semanticSupported={semanticSupported}
            onToggleSemantic={setSemanticEnabled}
            onSelectResult={handleOpenSearchResult}
            onClear={handleSearchReset}
          />
        )}

        {/* Content Area */}
        <CodexContent
          file={selectedFile}
          content={fileContent}
          metadata={fileMetadata}
          loading={loading}
          currentPath={currentPath}
          onNavigate={navigateToDirectory}
          onFetchFile={fetchFileContent}
          pathname={pathname}
          rememberScrollPosition={preferences.rememberScrollPosition ?? true}
          theme={preferences.theme}
          onPublish={handlePublishContent}
          files={files}
          onFileClick={handleFileClick}
          filterScope={searchOptions.filterScope}
          onActiveHeadingChange={setActiveHeadingSlug}
          showGitHubOptions={Boolean(selectedFile?.html_url)}
          allFiles={files}
          totalStrands={totalTreeStrands}
          totalWeaves={totalTreeWeaves}
          totalLooms={totalTreeLooms}
        />
      </div>

      {/* Right Panel - Unified (Metadata / Editor / Graph) */}
      {metaOpen && (
        <>
          {/* Mobile backdrop - higher z-index to cover everything */}
          <div 
            className="md:hidden fixed inset-0 bg-black/60 backdrop-blur-md"
            style={{ zIndex: Z_INDEX.rightPanelBackdrop }}
            onClick={() => handleToggleMetaPanel(false)}
          />
          <div 
            className={`
              /* Mobile: compact slide-up sheet, Desktop: side panel */
              fixed md:relative
              inset-x-0 md:inset-auto md:right-0 md:top-0 md:bottom-0
              w-full ${rightPanelWidthClass}
              /* Mobile: slide up from bottom, 70% height for compact view */
              bottom-0 md:bottom-auto
              h-[70vh] max-h-[70vh] md:h-full md:max-h-full md:min-h-0
              rounded-t-2xl md:rounded-none
              ${preferences.theme === 'dark' ? 'bg-obsidian-900' : ''}
              ${preferences.theme === 'light' ? 'bg-white' : ''}
              ${preferences.theme === 'sepia-light' ? 'bg-[#F4F1EA]' : ''}
              ${preferences.theme === 'sepia-dark' ? 'bg-[#1A0E0A]' : ''}
              ${preferences.theme === 'terminal-light' ? 'bg-[#F0F6E8]' : ''}
              ${preferences.theme === 'terminal-dark' ? 'bg-[#0D1F0C]' : ''}
              ${preferences.theme === 'oceanic-light' ? 'bg-[#F0F7FA]' : ''}
              ${preferences.theme === 'oceanic-dark' ? 'bg-[#0A1A24]' : ''}
              border-l-0 md:border-l ${preferences.theme.includes('dark') ? 'md:border-obsidian-800' : 'md:border-zinc-200'}
              shadow-2xl md:shadow-none
              flex flex-col
              touch-pan-y touch-pinch-zoom
              /* Animate in on mobile */
              transform transition-transform duration-300 ease-out
              md:transform-none
              /* Proper overflow for mobile */
              overflow-hidden
            `}
            style={{ 
              zIndex: layout.isMobile ? Z_INDEX.rightPanel : 'auto',
              touchAction: 'pan-y pinch-zoom',
              paddingBottom: layout.isMobile ? 'max(env(safe-area-inset-bottom, 0px), 16px)' : 0
            }}
          >
          {/* Mobile drag handle */}
          <div className="md:hidden flex flex-col items-center pt-2 pb-1 rounded-t-3xl">
            <div className="w-8 h-1 rounded-full bg-zinc-300 dark:bg-zinc-600" />
          </div>
          
          {/* Close button - refined design with subtle background */}
          <button
            onClick={() => handleToggleMetaPanel(false)}
            className={`
              absolute top-3 right-3 z-10 
              w-7 h-7 rounded-full
              flex items-center justify-center
              transition-all duration-200
              shadow-sm hover:shadow-md
              active:scale-95
              ${preferences.theme.includes('dark') 
                ? 'bg-zinc-800/90 text-zinc-400 hover:bg-zinc-700 hover:text-zinc-200 border border-zinc-700' 
                : 'bg-white/90 text-zinc-500 hover:bg-zinc-100 hover:text-zinc-800 border border-zinc-200'
              }
            `}
            aria-label="Close panel"
            title="Close panel (Esc)"
          >
            <X className="w-3.5 h-3.5" strokeWidth={2.5} />
          </button>

          {/* Panel Content - Show welcome stats on home, metadata when viewing a file */}
          <div className="flex-1 overflow-hidden min-h-0 h-full">
            {selectedFile ? (
              <CodexMetadataPanel
                isOpen={true}
                onClose={() => handleToggleMetaPanel(false)}
                metadata={fileMetadata}
                currentFile={selectedFile}
                allFiles={files}
                summaryInfo={currentSummary || undefined}
                content={fileContent}
                panelSize={metadataPanelSize}
                onPanelSizeChange={handleMetadataPanelSizeChange}
                currentPath={currentPath}
                onNavigate={(path) => {
                  // Handle URL navigation (e.g., /codex/browse?subject=computing)
                  if (path.startsWith('/codex/')) {
                    window.location.href = path
                    return
                  }
                  // Handle file navigation
                  const file = files.find(f => f.path === path)
                  if (file) {
                    handleFileClick(file)
                  } else {
                    fetchContents(path.replace(/\/[^/]+\.md$/, ''))
                  }
                }}
                autoExpandBacklinks={preferences.autoExpandBacklinks ?? true}
                activeHeadingSlug={activeHeadingSlug || undefined}
                theme={preferences.theme}
                onMetadataSave={handleMetadataSave}
                saveResult={lastSaveResult}
                isSavingMetadata={isSavingMetadata}
              />
            ) : (
              <CodexWelcomeStats
                theme={preferences.theme}
                totalStrands={totalTreeStrands}
                totalWeaves={totalTreeWeaves}
                totalLooms={totalTreeLooms}
                history={history}
                bookmarks={bookmarks}
                onNavigate={openFileFromTree}
                panelSize={metadataPanelSize}
                loading={knowledgeTreeLoading}
                randomFacts={randomFacts}
              />
            )}
          </div>
        </div>
        </>
      )}

      {/* Bookmarks Panel */}
      <BookmarksPanel
        isOpen={bookmarksOpen}
        onClose={() => setBookmarksOpen(false)}
        bookmarks={bookmarks}
        history={history}
        onNavigate={openFileFromTree}
        onRemoveBookmark={removeBookmark}
        onRemoveHistory={removeFromHistory}
        onClearBookmarks={clearAllBookmarks}
        onClearHistory={clearAllHistory}
      />

      {/* Preferences Modal */}
      <CodexSettingsModal
        isOpen={preferencesOpen}
        onClose={() => setPreferencesOpen(false)}
        initialTab="profile"
        preferences={preferences}
        onFontSizeChange={updateFontSize}
        onTreeDensityChange={updateTreeDensity}
        onSidebarModeChange={updateDefaultSidebarMode}
        onSidebarOpenMobileChange={updateSidebarOpenMobile}
        onHistoryTrackingChange={(enabled) => {
          updateMultiple({ historyTrackingEnabled: enabled })
          if (!enabled) {
            // When disabling history tracking, clear any existing history
            clearAllHistory()
          }
        }}
        onRememberScrollPositionChange={(enabled) => {
          updateMultiple({ rememberScrollPosition: enabled })
        }}
        onAutoExpandBacklinksChange={(enabled) => {
          updateMultiple({ autoExpandBacklinks: enabled })
        }}
        onReset={resetPreferences}
        onClearAll={() => {
          clearAllCodexData()
          setPreferencesOpen(false)
        }}
        // TTS Settings
        ttsVoices={tts.availableVoices}
        ttsSupported={tts.isSupported}
        onTTSVoiceChange={(voiceURI) => {
          const voice = tts.availableVoices.find(v => v.voiceURI === voiceURI)
          if (voice) {
            tts.setVoice(voice)
            updateMultiple({ tts: { ...preferences.tts, voiceURI, rate: tts.settings.rate, volume: tts.settings.volume, pitch: tts.settings.pitch } })
          }
        }}
        onTTSRateChange={(rate) => {
          tts.setRate(rate)
          updateMultiple({ tts: { ...preferences.tts, rate, volume: tts.settings.volume, pitch: tts.settings.pitch } })
        }}
        onTTSVolumeChange={(volume) => {
          tts.setVolume(volume)
          updateMultiple({ tts: { ...preferences.tts, volume, rate: tts.settings.rate, pitch: tts.settings.pitch } })
        }}
        onTTSPitchChange={(pitch) => {
          tts.setPitch(pitch)
          updateMultiple({ tts: { ...preferences.tts, pitch, rate: tts.settings.rate, volume: tts.settings.volume } })
        }}
      />

      {/* Tutorial Tour */}
      {activeTutorial && (
        <TutorialTour
          tourId={TUTORIALS[activeTutorial].id}
          title={TUTORIALS[activeTutorial].title}
          steps={TUTORIALS[activeTutorial].steps}
          isActive={!!activeTutorial}
          onComplete={() => setActiveTutorial(null)}
          onSkip={() => setActiveTutorial(null)}
        />
      )}

      {/* Help/Info Panel */}
      <HelpInfoPanel isOpen={helpOpen} onClose={() => setHelpOpen(false)} />

      {/* Knowledge Graph View (Simple spiral) */}
      {graphOpen && (
        <KnowledgeGraphView
          tree={knowledgeTree}
          selectedPath={selectedFile?.path}
          onNavigate={openFileFromTree}
          onClose={() => setGraphOpen(false)}
        />
      )}

      {/* Fabric Graph View (Advanced multi-level) */}
      {fabricGraphOpen && (
        <FabricGraphView
          tree={knowledgeTree}
          tagsIndex={tagsIndex}
          selectedPath={selectedFile?.path}
          onNavigate={openFileFromTree}
          onClose={() => setFabricGraphOpen(false)}
          theme={preferences.theme}
        />
      )}

      {/* Timeline View */}
      {timelineOpen && (
        <TimelineView
          history={history}
          onNavigate={openFileFromTree}
          onClose={() => setTimelineOpen(false)}
        />
      )}

      {/* Contribute Modal */}
      <ContributeModal
        isOpen={contributeOpen}
        onClose={() => setContributeOpen(false)}
        currentPath={currentPath}
      />

      {/* Settings Modal */}
      <SettingsModal
        isOpen={settingsOpen}
        onClose={() => setSettingsOpen(false)}
      />

      {/* Move Publish Modal */}
      <MovePublishModal
        isOpen={moveModalOpen}
        onClose={() => setMoveModalOpen(false)}
        operations={pendingMoves}
        onPublish={handlePublishMoves}
        onClearAll={handleClearMoves}
        onRemoveOperation={handleRemoveMove}
        isDark={preferences.theme?.includes('dark')}
      />

      {/* Strand Editor */}
      {selectedFile && (
        <StrandEditor
          file={selectedFile}
          content={editorDraft?.content ?? fileContent}
          metadata={editorDraft?.metadata ?? fileMetadata}
          isOpen={editorOpen}
          onClose={() => {
            setEditorOpen(false)
            setEditorDraft(null)
          }}
          onSave={async (content, metadata) => {
            if (!selectedFile) return

            try {
              // Extract content body (without frontmatter)
              const contentBody = content.replace(/^---[\s\S]*?---\n*/, '')

              // Build content source config
              const contentSource = {
                type: 'sqlite' as const,
                isOnline: navigator.onLine,
                lastSync: null,
                pendingChanges: 0,
              }

              // Check for GitHub PAT
              const githubPat = preferences.githubPAT?.trim()
              const hasGitHubPat = Boolean(githubPat && githubPat.length > 0)

              // Save to local database (and GitHub if PAT configured)
              const result = await saveStrandMetadata({
                strand: metadata,
                originalStrand: fileMetadata,
                contentBody,
                strandPath: selectedFile.path,
                contentSource,
                vaultHandle: undefined,
                githubConfig: hasGitHubPat ? {
                  owner: REPO_CONFIG.OWNER,
                  repo: REPO_CONFIG.NAME,
                  branch: REPO_CONFIG.BRANCH,
                  pat: githubPat,
                } : undefined,
              })

              // Show success feedback
              if (result.savedTo.length > 0) {
                const targetsText = result.savedTo.join(', ')
                if (result.prUrl) {
                  toast.success(`Saved to ${targetsText}. PR created!`)
                } else {
                  toast.success(`Saved to ${targetsText}`)
                }

                // Update local content state
                setFileContent(content)
                setFileMetadata(metadata)
              }

              // Show any errors
              if (result.errors.length > 0) {
                const errorText = result.errors.map(e => `${e.target}: ${e.error}`).join('; ')
                toast.error(`Some saves failed: ${errorText}`)
              }
            } catch (error) {
              console.error('[StrandEditor] Save failed:', error)
              toast.error(`Failed to save: ${error instanceof Error ? error.message : 'Unknown error'}`)
            }

            setEditorOpen(false)
            setEditorDraft(null)
          }}
          theme={preferences.theme}
          repo={{
            owner: REPO_CONFIG.OWNER,
            repo: REPO_CONFIG.NAME,
            defaultBranch: REPO_CONFIG.BRANCH,
          }}
        />
      )}

      {/* Ask Tab - Unified tabulated interface (Local + LLM + Hybrid modes) */}
      {/* Unified Ask Interface - Brain + Cloud AI + Hybrid */}
      <UnifiedAskInterface
        isOpen={qaOpen}
        onClose={() => setQAOpen(false)}
        currentStrand={selectedFile?.path}
        strandContent={fileContent || ''}
        strandTitle={selectedFile?.name || fileMetadata.title}
        theme={preferences.theme || 'dark'}
        availableWeaves={[]}
        availableLooms={[]}
        availableTags={[
          ...tagsIndex.tags.map(t => t.name),
          ...tagsIndex.subjects.map(s => s.name),
          ...tagsIndex.topics.map(t => t.name),
        ]}
        totalStrands={totalTreeStrands}
      />

      {/* Flashcard Quiz Popover */}
      {flashcardsOpen && selectedFile && (
        <FlashcardQuizPopover
          isOpen={flashcardsOpen}
          onClose={() => setFlashcardsOpen(false)}
          strandSlug={selectedFile.path}
          content={fileContent || ''}
          theme={preferences.theme}
        />
      )}

      {/* Glossary Popover */}
      {glossaryOpen && selectedFile && (
        <GlossaryPopover
          isOpen={glossaryOpen}
          onClose={() => setGlossaryOpen(false)}
          strandSlug={selectedFile.path}
          content={fileContent || ''}
          theme={preferences.theme}
        />
      )}

      {/* Mind Map */}
      {selectedFile && (
        <StrandMindMap
          isOpen={mindMapOpen}
          onClose={() => setMindMapOpen(false)}
          currentPath={selectedFile.path}
          files={files}
          metadata={fileMetadata as any}
          knowledgeTree={knowledgeTree}
          theme={preferences.theme}
          onNavigate={(path) => {
            const file = files.find(f => f.path === path)
            if (file) {
              handleFileClick(file)
            }
            setMindMapOpen(false)
          }}
        />
      )}

      {/* Keyboard Shortcuts Modal */}
      <KeyboardShortcutsModal
        isOpen={shortcutsOpen}
        onClose={() => setShortcutsOpen(false)}
        theme={preferences.theme}
      />

      {/* Mobile Bottom Navigation */}
      <MobileBottomNav
        activeTab={selectedFile ? 'home' : undefined}
        onHome={() => {
          setSelectedFile(null)
          setFileContent('')
          setCurrentPath('')
          setSearchQuery('')
          window.location.href = '/codex/'
        }}
        onSearch={() => {
          const input = document.getElementById('codex-search-input') as HTMLInputElement | null
          input?.focus()
          setSidebarOpen(true)
        }}
        onAsk={() => {
          setQAOpen(true)
        }}
        onInfo={() => {
          setMetaOpen(true)
          setSidebarOpen(false)
        }}
        onSettings={() => {
          setPreferencesOpen(true)
          setSidebarOpen(false)
        }}
      />

      {/* Background Job Status Panel */}
      <JobStatusPanel
        theme={preferences.theme}
        onViewResults={(job) => {
          // Navigate to appropriate view based on job type
          if (job.type === 'flashcard_generation') {
            // Could open flashcard quiz popover
          } else if (job.type === 'glossary_generation') {
            // Could open glossary popover
          }
        }}
      />
      
    </div>
  )

  // Modal mode
  if (isModal) {
    return (
      <AnimatePresence>
        {isOpen && (
          <>
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              className="fixed inset-0 bg-black/60 dark:bg-black/80 z-[60] backdrop-blur-md"
              onClick={onClose}
            />

            <div className="fixed inset-0 z-[70] flex items-center justify-center p-4">
            <motion.div
              initial={{ opacity: 0, scale: 0.95 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.95 }}
              className="codex-viewer w-full max-w-7xl h-[90vh] bg-white dark:bg-obsidian-950 border border-zinc-200 dark:border-obsidian-800 overflow-hidden shadow-2xl flex rounded-xl ring-1 ring-white/10"
            >
              {content}
            </motion.div>
            </div>
          </>
        )}
      </AnimatePresence>
    )
  }

  // Page mode - NO CodexTopNav here since the toolbar IS the navigation
  // Left sidebar + Center toolbar/content + Optional right sidebar
  return (
    <div className="codex-viewer w-full h-[100dvh] flex flex-col md:flex-row relative overflow-hidden">
      {content}
    </div>
  )
}
